diff --git a/sec-driver/src/sec_driver.c b/sec-driver/src/sec_driver.c
index e6687be..ad053dc 100755
--- a/sec-driver/src/sec_driver.c
+++ b/sec-driver/src/sec_driver.c
@@ -1262,7 +1262,7 @@ sec_return_code_t sec_init(const sec_config_t *sec_config_data,
     {
         SEC_INFO("Allocated %u KB for SEC driver, remaining free %lu KB",
                 ((dma_addr_t)g_dma_mem_free - (dma_addr_t)g_dma_mem_start)/1024,
-                (DMA_MEM_SEC_DRIVER - ((dma_addr_t)(dma_addr_t)g_dma_mem_free - (dma_addr_t)g_dma_mem_start))/1024);
+                (SEC_DMA_MEMORY_SIZE - ((dma_addr_t)(dma_addr_t)g_dma_mem_free - (dma_addr_t)g_dma_mem_start))/1024);
     }
     else
     {
diff --git a/sec-driver/src/sec_hw_specific.h b/sec-driver/src/sec_hw_specific.h
index 6960556..9cabbe6 100755
--- a/sec-driver/src/sec_hw_specific.h
+++ b/sec-driver/src/sec_hw_specific.h
@@ -517,6 +517,10 @@ but do not reset FIFO with jobs. See SEC 3.1 reference manual for more details.
 #define CMD_PROTO_DECAP                         0x06
 #define CMD_PROTO_ENCAP                         0x07
 
+#define CMD_ALGORITHM_ICV                       0x02
+
+#define CMD_ALGORITHM_ENCRYPT                   0x01
+
 #define PDCP_SD_KEY_LEN     0x4
 
 
@@ -793,8 +797,8 @@ but do not reset FIFO with jobs. See SEC 3.1 reference manual for more details.
             __i++)                                                          \
         {                                                                   \
             SEC_DEBUG("0x%08x: 0x%08x",                                     \
-                    (uint32_t)(((uint32_t*)(descriptor)) + __i),            \
-                    *(((uint32_t*)(descriptor)) + __i));                    \
+                     (uint32_t)(((uint32_t*)(descriptor)) + __i),           \
+                     *(((uint32_t*)(descriptor)) + __i));                   \
         }                                                                   \
 }
 
@@ -1102,11 +1106,13 @@ typedef struct sec_crypto_pdb_s
 struct sec_pdcp_sd_t{
     struct descriptor_header_s  deschdr;
     sec_crypto_pdb_t            pdb;
+
     struct key_command_s        key2_cmd;
     uint32_t                    key2[PDCP_SD_KEY_LEN];
     struct key_command_s        key1_cmd;
     uint32_t                    key1[PDCP_SD_KEY_LEN];
     struct protocol_operation_command_s protocol;
+
 } PACKED;
 
 /** Structure encompassing a job descriptor which processes
diff --git a/sec-driver/src/sec_pdcp.c b/sec-driver/src/sec_pdcp.c
index 50cfc53..c083d3b 100755
--- a/sec-driver/src/sec_pdcp.c
+++ b/sec-driver/src/sec_pdcp.c
@@ -1449,18 +1449,154 @@ static int create_c_plane_mixed_desc(sec_context_t *crypto_pdb)
     return SEC_SUCCESS;
 }
 
-static int create_c_plane_auth_only_desc(sec_context_t *crypto_pdb)
+static int create_c_plane_auth_only_desc(sec_context_t *ctx)
 {
-    SEC_INFO(" Called create_auth_only_desc");
-    ASSERT(0);
+    int i = 5;
+
+    switch( ctx->pdcp_crypto_info->integrity_algorithm )
+    {
+        case SEC_ALG_SNOW:
+            SEC_INFO(" SNOW f9 auth-only not supported.\n");
+            ASSERT(0);
+            break;
+        case SEC_ALG_AES:
+            SEC_INFO(" Creating NULL/AES-CMAC descriptor.");
+
+            ctx->sh_desc->deschdr.command.word  = 0xB8850100;
+            *((uint32_t*)ctx->sh_desc + i++) = 0x02800010;     // key1, imm, len 0x10
+            SEC_PDCP_SD_COPY_KEY( ((uint32_t*)(ctx->sh_desc) + i),
+                                   ctx->pdcp_crypto_info->integrity_key,
+                                   ctx->pdcp_crypto_info->integrity_key_len );
+            i+=ctx->pdcp_crypto_info->integrity_key_len/sizeof(uint32_t);
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x1e080001;     // seq load, class 3, length = 1, dest = m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa1001001;     // wait for calm
+            *((uint32_t*)ctx->sh_desc + i++) = 0xac804108;     // shift right 24 bits, put result in math1
+            *((uint32_t*)ctx->sh_desc + i++) = 0x00000018;     // 24
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79360808;     // move from desc buf to math2, wc=1,offset = 8, len 8
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa8412208;     // or Math2 w/Math1, put result in Math2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x78680008;     // move math2 to class1 input fifo(IV=64bits)
+
+            if( ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION )
+            {
+                // outbound
+                *((uint32_t*)ctx->sh_desc + i++) = 0xa828f104;     // M1 = SIL-0x00
+            }
+            else
+            {
+                *((uint32_t*)ctx->sh_desc + i++) = 0xa8284104;  // M1 = SIL-0x04 (ICV size)
+                *((uint32_t*)ctx->sh_desc + i++) = 0x00000004;  // 4
+            }
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa821fa04;     // VSIL = M1-0x00
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa821fb04;     // VSOL = M1-0x00
+
+            if( ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION )
+            {
+                *((uint32_t*)ctx->sh_desc + i++) = 0x2f170000;  // seq fifo load, class1, class2, LC1, LC2, FC1 vlf
+            }
+            else
+            {
+                *((uint32_t*)ctx->sh_desc + i++) = 0x2f100000;  // seq fifo load, class1, class2, vlf
+                *((uint32_t*)ctx->sh_desc + i++) = 0x2e3f0004;  // seq fifo load, class1, class2, len = 4
+            }
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x8210060C | \
+                    ( (ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION) ? \
+                       0 : CMD_ALGORITHM_ICV );         // operation: optype = 2 (class 1), alg = 0x10 (aes), aai = 0x60 (cmac), as = 11 (int/fin), icv = 0, enc = 0 (ignored)
+            *((uint32_t*)ctx->sh_desc + i++) = 0x70920001;     // move from C2 align block to Output fifo, len = M1 = VSIL
+            *((uint32_t*)ctx->sh_desc + i++) = 0x5e080001;     // seq store, class 3, length = 1, src=m0 ( header )
+            *((uint32_t*)ctx->sh_desc + i++) = 0x69300000;     // seq fifo store, vlf
+            *((uint32_t*)ctx->sh_desc + i++) = 0x5a200004;     // seqstr: ctx1 len=4 offs=0
+
+            // update descriptor length
+            ctx->sh_desc->deschdr.command.sd.desclen = i;
+
+            break;
+        default:
+            SEC_INFO(" Unknown integrity algorithm requested: %d", ctx->pdcp_crypto_info->integrity_algorithm);
+            ASSERT(0);
+            break;
+    }
+    SEC_PDCP_DUMP_DESC(ctx->sh_desc);
 
     return SEC_SUCCESS;
 }
 
-static int create_c_plane_cipher_only_desc(sec_context_t *crypto_pdb)
+static int create_c_plane_cipher_only_desc(sec_context_t *ctx)
 {
-    SEC_INFO(" Called create_cipher_only_desc");
-    ASSERT(0);
+    int i = 5;
+
+    switch( ctx->pdcp_crypto_info->cipher_algorithm )
+    {
+        case SEC_ALG_SNOW:
+            SEC_INFO(" Creating SNOW f8/NULL descriptor.");
+
+            ctx->sh_desc->deschdr.command.word = 0xb8850100;  // shared header, start idx = 5
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x02800010;  // key1, imm, len 0x10
+            SEC_PDCP_SD_COPY_KEY( ((uint32_t*)(ctx->sh_desc) + i),
+                                  ctx->pdcp_crypto_info->cipher_key,
+                                  ctx->pdcp_crypto_info->cipher_key_len );
+            i+=ctx->pdcp_crypto_info->cipher_key_len/sizeof(uint32_t);
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x1e080001;      // seq load, class 3, length = 1, dest = m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa1001001;      // wait for calm
+            *((uint32_t*)ctx->sh_desc + i++) = 0xac804108;      // shift right 24 bits, put result in math1
+            *((uint32_t*)ctx->sh_desc + i++) = 0x00000018;      // 24
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79360808;      // move from desc buf to math2, wc=1,offset = 8, len 8
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa8412208;      // or Math2 w/Math1, put result in Math2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x5e080001;      // seq store, class 3, length = 1, src=m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79600008;      // load, class1 ctx, math2, wc = 1, len 8, offset 0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa808fa04;      // VSIL=SIL (VSIL=SIL+0x00)
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa809fb04;      // VSOL=SOL (VSOL=SOL+0x00)
+            *((uint32_t*)ctx->sh_desc + i++) = 0x2b170000;      // seq fifo load, class1, vlf, LC1,LC2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x69300000;      // SEQ FIFO STORE, vlf
+            *((uint32_t*)ctx->sh_desc + i++) = 0x82600c0c| \
+                    ( (ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION) ? \
+                    CMD_ALGORITHM_ENCRYPT : 0 );      // operation, optype = 2 (class 1), alg = 0x60 (snow), aai = 0xC0 (f8), as = 11 (int/fin), icv = 0, enc = 0
+
+            // update descriptor length
+            ctx->sh_desc->deschdr.command.sd.desclen = i;
+
+            break;
+
+        case SEC_ALG_AES:
+            SEC_INFO(" Creating AES-CMAC/NULL descriptor.");
+
+            ctx->sh_desc->deschdr.command.word = 0xb8850100;  // shared header, start idx = 5
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x02800010;  // key1, imm, len 0x10
+            SEC_PDCP_SD_COPY_KEY( ((uint32_t*)(ctx->sh_desc) + i),
+                                  ctx->pdcp_crypto_info->cipher_key,
+                                  ctx->pdcp_crypto_info->cipher_key_len );
+            i+=ctx->pdcp_crypto_info->cipher_key_len/sizeof(uint32_t);
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x1e080001;  // seq load, class 3, length = 1, dest = m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa1001001;  // wait for calm
+            *((uint32_t*)ctx->sh_desc + i++) = 0xac804108;  // shift right 24 bits, put result in math1
+            *((uint32_t*)ctx->sh_desc + i++) = 0x00000018;  // 24
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79360808;  // move from desc buf to math2, wc=1,offset = 8, len 8
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa8412208;  // or Math2 w/Math1, put result in Math2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x5e080001;  // seq store, class 3, length = 1, src=m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79601010;  // load, class1 ctx, math2, wc = 1, len 16, offset 16
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa808fa04;  // VSIL=SIL (VSIL=SIL+0x00)
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa809fb04;  // VSOL=SOL (VSOL=SOL+0x00)
+            *((uint32_t*)ctx->sh_desc + i++) = 0x2b170000;  // seq fifo load, class1, vlf, LC1,LC2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x69300000;  // SEQ FIFO STORE, vlf
+            *((uint32_t*)ctx->sh_desc + i++) = 0x8210000d | \
+                    ( (ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION) ? \
+                       CMD_ALGORITHM_ENCRYPT : 0 );  // operation: optype = 2 (class 1), alg = 0x10 (aes), aai = 0x00 (ctr), as = 11 (int/fin), icv = 0, enc = 1
+
+            // update descriptor length
+            ctx->sh_desc->deschdr.command.sd.desclen = i;
+            break;
+        default:
+            SEC_INFO(" Unknown integrity algorithm requested: %d", ctx->pdcp_crypto_info->cipher_algorithm);
+            ASSERT(0);
+            break;
+    }
+
+    SEC_PDCP_DUMP_DESC(ctx->sh_desc);
 
     return SEC_SUCCESS;
 }
@@ -1590,9 +1726,9 @@ int sec_pdcp_context_update_descriptor(sec_context_t *ctx,
  */
 static create_desc_fp c_plane_create_desc[NUM_CIPHER_ALGS][NUM_INT_ALGS] = {
         /*              NULL                                SNOW                                    AES */
-        /* NULL */{create_null_desc,                create_c_plane_cipher_only_desc,    create_c_plane_cipher_only_desc },
-        /* SNOW */{create_c_plane_auth_only_desc,   create_c_plane_hw_acc_desc,         create_c_plane_mixed_desc       },
-        /* AES  */{create_c_plane_auth_only_desc,   create_c_plane_mixed_desc,          create_c_plane_hw_acc_desc      },
+        /* NULL */{create_null_desc,                  create_c_plane_auth_only_desc,      create_c_plane_auth_only_desc     },
+        /* SNOW */{create_c_plane_cipher_only_desc,   create_c_plane_hw_acc_desc,         create_c_plane_mixed_desc         },
+        /* AES  */{create_c_plane_cipher_only_desc,   create_c_plane_mixed_desc,          create_c_plane_hw_acc_desc        },
 };
 
 /** Static array for selection of the function to be used for creating the shared descriptor on a SEC context,
diff --git a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c
index 5ec55a1..3d6a310 100755
--- a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c
+++ b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c
@@ -614,7 +614,7 @@ static int pdcp_ready_packet_handler (const sec_packet_t *in_packet,
     int test_failed = 0;
     // Check if packet is valid
     test_failed = !is_packet_valid(pdcp_context, in_packet, out_packet, status);
-
+test_printf("out packet lenght: %d\n",out_packet->length);
     if(test_failed)
     {
         test_printf("\nthread #%d:consumer: out packet INCORRECT!."
diff --git a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h
index 185b3a6..c1fd096 100755
--- a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h
+++ b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h
@@ -75,7 +75,7 @@
 
 // Test control plane PDCP with NULL-crypto(EEA0)
 // and NULL-authentication(EIA0) algorithms set
-#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_ALGO
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_ALGO
 
 // Test PDCP control plane encapsulation with SNOW F8 ciphering
 // and SNOW F9 authentication
@@ -107,12 +107,29 @@
 // and AES CMAC authentication
 //#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_SNOW_F8_AES_CMAC_DEC
 
+// Test PDCP control plane encapsulation with SNOW F8 ciphering
+// and NULL authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
 
 // Test PDCP control plane decapsulation with SNOW F8 ciphering
 // and NULL authentication
 //#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 
+// Test PDCP control plane encapsulation with AES-CTR ciphering
+// and NULL authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+
+// Test PDCP control plane dencpsulation with AES-CTR ciphering
+// and NULL authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+
+// Test PDCP control plane encapsulation with NULL ciphering
+// and AES-CMAC authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
 
+// Test PDCP control plane decapsulation with NULL ciphering
+// and AES-CMAC authentication
+#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
 
 
 //////////////////////////////////////////////////////////////////////////////
@@ -141,10 +158,10 @@
 //////////////////////////////////////////////////////////////////////////////
 
 // Disable test application logging
-#define test_printf(format, ...)
+//#define test_printf(format, ...)
 
 // Enable test application logging
-//#define test_printf(format, ...) printf("%s(): " format "\n", __FUNCTION__,  ##__VA_ARGS__)
+#define test_printf(format, ...) printf("%s(): " format "\n", __FUNCTION__,  ##__VA_ARGS__)
 
 /******************************************************************************/
 // END OF CONFIGURATION SECTION
@@ -181,7 +198,18 @@
 #define PDCP_TEST_CTRL_PLANE_AES_CTR_SNOW_F9_DEC    15
 #define PDCP_TEST_CTRL_PLANE_SNOW_F8_AES_CMAC_ENC   16
 #define PDCP_TEST_CTRL_PLANE_SNOW_F8_AES_CMAC_DEC   17
-#define PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC       18
+
+#define PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC       18
+#define PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC       19
+
+#define PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC       20
+#define PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC       21
+
+#define PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC      22
+#define PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC      23
+
+
+
 /*==============================================================================
                          GLOBAL VARIABLE DECLARATIONS
 ==============================================================================*/
diff --git a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h
index ae7f76b..211c05b 100755
--- a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h
+++ b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h
@@ -811,47 +811,229 @@ static uint32_t snow_f8_aes_cmac_dec_hfn = 0xFA556;
 static uint32_t snow_f8_aes_cmac_dec_hfn_threshold = 0xFF00000;
 
 //////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC"
+
+// Extracted from ETSI TS 135 203  V10.0.0  (2011-04)
+// Section 4, Test Set 3
+
+#define PDCP_HEADER_LENGTH 1
+
+static uint8_t snow_f8_null_enc_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
++                                    0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
+// PDCP header
+static uint8_t snow_f8_null_enc_pdcp_hdr[] = {0x26};
+
+// PDCP payload not encrypted
+static uint8_t snow_f8_null_enc_data_in[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                        0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+
+// PDCP payload encrypted
+static uint8_t snow_f8_null_enc_data_out[] = {0xBA,0x0F,0x31,0x30,0x03,0x34,0xC5,0x6B, // PDCP payload encrypted
+                                         0x52,0xA7,0x49,0x7C,0xBA,0xC0,0x46};
+
+// Radio bearer id
+static uint8_t snow_f8_null_enc_bearer = 0x3;
+
+// Start HFN
+static uint32_t snow_f8_null_enc_hfn = 0x7D2AB59;
+
+// HFN threshold
+static uint32_t snow_f8_null_enc_hfn_threshold = 0x7D2AB5a;
+
+//////////////////////////////////////////////////////////////////////////////
 // PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 //////////////////////////////////////////////////////////////////////////////
 #elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 
 #define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC"
 
-// WE HAVE NO PDCP CONTROL-PLANE TEST VECTORS AVAILABLE!
-// Output data was obtained by running encapsulation test.
-// Then the reverse, decapsulation test was done to obtain back the original data.
-// This is the method used for validating to some extent the PDCP control-plane algorithms.
+// Extracted from ETSI TS 135 203  V10.0.0  (2011-04)
+// Section 4, Test Set 3
 
 // Length of PDCP header
 #define PDCP_HEADER_LENGTH 1
 
-// Crypto key
+
 static uint8_t snow_f8_null_dec_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
-                                         0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
-// Authentication key
-static uint8_t snow_f8_null_dec_auth_key[] = {0xC7,0x36,0xC6,0xAA,0xB2,0x2B,0xFF,0xF9,
-                                              0x1E,0x26,0x98,0xD2,0xE2,0x2A,0xD5,0x7E};
+                                    0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
 // PDCP header
-static uint8_t snow_f8_null_dec_pdcp_hdr[] = {0x8B};
-
-// PDCP payload + MAC-I both encrypted
-static uint8_t snow_f8_null_dec_data_in[] =  {0x20,0xd9,0x97,0x63,0x60,0x68,0x2d,0x55,0x0e,0x8d,
-                                              0x50,0x0a,0xc7,0xfc,0x5e};
+static uint8_t snow_f8_null_dec_pdcp_hdr[] = {0x26};
 
 // PDCP payload not encrypted
 static uint8_t snow_f8_null_dec_data_out[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
-                                                  0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+                                         0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+
+// PDCP payload encrypted
+static uint8_t snow_f8_null_dec_data_in[] = { 0xBA,0x0F,0x31,0x30,0x03,0x34,0xC5,0x6B, // PDCP payload encrypted
+                                         0x52,0xA7,0x49,0x7C,0xBA,0xC0,0x46};
 // Radio bearer id
 static uint8_t snow_f8_null_dec_bearer = 0x3;
 
 // Start HFN
-static uint32_t snow_f8_null_dec_hfn = 0xFA556;
+static uint32_t snow_f8_null_dec_hfn = 0x7D2AB59;
+
+// HFN threshold
+static uint32_t snow_f8_null_dec_hfn_threshold = 0xFA557;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC"
+// ETSI TS 133 401  V9.6.0 (2011-01)
+// EEA2 - Test set 1
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+
+static uint8_t aes_ctr_null_enc_key[] = {0xd3, 0xc5, 0xd5, 0x92, 0x32, 0x7f, 0xb1, 0x1c,
+                                    0x40, 0x35, 0xc6, 0x68, 0x0a, 0xf8, 0xc6, 0xd1};
+
+// PDCP header
+static uint8_t aes_ctr_null_enc_pdcp_hdr[] = {0xB4};
+
+// PDCP payload not encrypted
+static uint8_t aes_ctr_null_enc_data_in[] = {0x98, 0x1b, 0xa6, 0x82, 0x4c, 0x1b, 0xfb, 0x1a,
+                                        0xb4, 0x85, 0x47, 0x20, 0x29, 0xb7, 0x1d, 0x80,
+                                        0x8c, 0xe3, 0x3e, 0x2c, 0xc3, 0xc0, 0xb5, 0xfc,
+                                        0x1f, 0x3d, 0xe8, 0xa6, 0xdc, 0x66, 0xb1, 0xf0};
+
+
+// PDCP payload encrypted
+static uint8_t aes_ctr_null_enc_data_out[] = {0xe9, 0xfe, 0xd8, 0xa6, 0x3d, 0x15, 0x53, 0x04,
+                                         0xd7, 0x1d, 0xf2, 0x0b, 0xf3, 0xe8, 0x22, 0x14,
+                                         0xb2, 0x0e, 0xd7, 0xda, 0xd2, 0xf2, 0x33, 0xdc,
+                                         0x3c, 0x22, 0xd7, 0xbd, 0xee, 0xed, 0x8e, 0x78};
+// Radio bearer id
+static uint8_t aes_ctr_null_enc_bearer = 0x15;
+// Start HFN
+//static uint32_t aes_ctr_enc_hfn = 0x398A5;
+static uint32_t aes_ctr_null_enc_hfn = 0x1CC52CD;
+
+// HFN threshold
+static uint32_t aes_ctr_null_enc_hfn_threshold = 0x398A6;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC"
+// ETSI TS 133 401  V9.6.0 (2011-01)
+// EEA2 - Test set 1
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+
+static uint8_t aes_ctr_null_dec_key[] = {0xd3, 0xc5, 0xd5, 0x92, 0x32, 0x7f, 0xb1, 0x1c,
+                                    0x40, 0x35, 0xc6, 0x68, 0x0a, 0xf8, 0xc6, 0xd1};
+
+// PDCP header
+static uint8_t aes_ctr_null_dec_pdcp_hdr[] = {0xB4};
+
+// PDCP payload not encrypted
+static uint8_t aes_ctr_null_dec_data_out[] = {0x98, 0x1b, 0xa6, 0x82, 0x4c, 0x1b, 0xfb, 0x1a,
+                                        0xb4, 0x85, 0x47, 0x20, 0x29, 0xb7, 0x1d, 0x80,
+                                        0x8c, 0xe3, 0x3e, 0x2c, 0xc3, 0xc0, 0xb5, 0xfc,
+                                        0x1f, 0x3d, 0xe8, 0xa6, 0xdc, 0x66, 0xb1, 0xf0};
+
+
+// PDCP payload encrypted
+static uint8_t aes_ctr_null_dec_data_in[] = {0xe9, 0xfe, 0xd8, 0xa6, 0x3d, 0x15, 0x53, 0x04,
+                                         0xd7, 0x1d, 0xf2, 0x0b, 0xf3, 0xe8, 0x22, 0x14,
+                                         0xb2, 0x0e, 0xd7, 0xda, 0xd2, 0xf2, 0x33, 0xdc,
+                                         0x3c, 0x22, 0xd7, 0xbd, 0xee, 0xed, 0x8e, 0x78};
+// Radio bearer id
+static uint8_t aes_ctr_null_dec_bearer = 0x15;
+
+// Start HFN
+static uint32_t aes_ctr_null_dec_hfn = 0x1CC52CD;
+
+// HFN threshold
+static uint32_t aes_ctr_null_dec_hfn_threshold = 0x398A6;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NUL_AES_CMAC_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC"
+// ETSI TS 133 401  V9.6.0 (2011-01)
+// EIA2 - Test set 2
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+// PDCP header
+static uint8_t null_aes_cmac_enc_pdcp_hdr[] = {0x14};
+
+static uint8_t null_aes_cmac_enc_key[] = {0xd3, 0xc5, 0xd5, 0x92, 0x32, 0x7f, 0xb1, 0x1c,
+                                          0x40, 0x35, 0xc6, 0x68, 0x0a, 0xf8, 0xc6, 0xd1};
+
+
+// PDCP payload not encrypted
+static uint8_t null_aes_cmac_enc_data_out[] = {0x48, 0x45,0x83,0xd5,0xaf,0xe0,0x82,0xae, /* payload */
+                                               0xb9,0x37,0x87,0xe6 /* ICV */ };
+
+
+// PDCP payload encrypted
+static uint8_t null_aes_cmac_enc_data_in[] = {0x48, 0x45,0x83,0xd5,0xaf,0xe0,0x82,0xae};
+
+// Radio bearer id
+static uint8_t null_aes_cmac_enc_bearer = 0x1a;
+
+// Start HFN
+static uint32_t null_aes_cmac_enc_hfn = 0x1CC52CD;
+
+// HFN threshold
+static uint32_t null_aes_cmac_enc_hfn_threshold = 0xFF00000;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NUL_AES_CMAC_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC"
+// ETSI TS 133 401  V9.6.0 (2011-01)
+// EIA2 - Test set 2
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+// PDCP header
+static uint8_t null_aes_cmac_dec_pdcp_hdr[] = {0x14};
+
+static uint8_t null_aes_cmac_dec_key[] = {0xd3, 0xc5, 0xd5, 0x92, 0x32, 0x7f, 0xb1, 0x1c,
+                                    0x40, 0x35, 0xc6, 0x68, 0x0a, 0xf8, 0xc6, 0xd1};
+
+
+// PDCP payload not encrypted
+static uint8_t null_aes_cmac_dec_data_in[] = { 0x48, 0x45,0x83,0xd5,0xaf,0xe0,0x82,0xae, /* payload */
+                                               0xb9,0x37,0x87,0xe6 /* ICV */ };
+
+
+// PDCP payload encrypted
+static uint8_t null_aes_cmac_dec_data_out[] = {0x48, 0x45,0x83,0xd5,0xaf,0xe0,0x82,0xae, /* payload */
+                                               0xb9,0x37,0x87,0xe6 /* ICV */};
+
+// Radio bearer id
+static uint8_t null_aes_cmac_dec_bearer = 0x1a;
+
+// Start HFN
+static uint32_t null_aes_cmac_dec_hfn = 0x1CC52CD;
 
 // HFN threshold
-static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
+static uint32_t null_aes_cmac_dec_hfn_threshold = 0xFF00000;
 
 #else
-#error "Unsuported test scenario!"
+#error "Unsupported test scenario!"
 #endif
 
 
@@ -1360,6 +1542,32 @@ static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
 //#endif
 
 //////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+
+#define test_crypto_key         snow_f8_null_enc_key
+#define test_crypto_key_len     sizeof(snow_f8_null_enc_key)
+
+#define test_auth_key           NULL
+#define test_auth_key_len       0
+
+#define test_data_in            snow_f8_null_enc_data_in
+#define test_data_out           snow_f8_null_enc_data_out
+
+#define test_pdcp_hdr           snow_f8_null_enc_pdcp_hdr
+#define test_bearer             snow_f8_null_enc_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_SNOW
+#define test_integrity_algorithm SEC_ALG_NULL
+#define test_hfn                snow_f8_null_enc_hfn
+#define test_hfn_threshold      snow_f8_null_enc_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
 // PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 //////////////////////////////////////////////////////////////////////////////
 #elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
@@ -1367,8 +1575,8 @@ static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
 #define test_crypto_key         snow_f8_null_dec_key
 #define test_crypto_key_len     sizeof(snow_f8_null_dec_key)
 
-#define test_auth_key           snow_f8_null_dec_auth_key
-#define test_auth_key_len       sizeof(snow_f8_null_dec_auth_key)
+#define test_auth_key           NULL
+#define test_auth_key_len       0
 
 #define test_data_in            snow_f8_null_dec_data_in
 #define test_data_out           snow_f8_null_dec_data_out
@@ -1390,6 +1598,111 @@ static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
 //#ifdef VALIDATE_CONFORMITY
 //#undef VALIDATE_CONFORMITY
 //#endif
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+
+#define test_crypto_key         aes_ctr_null_enc_key
+#define test_crypto_key_len     sizeof(aes_ctr_null_enc_key)
+
+#define test_auth_key           NULL
+#define test_auth_key_len       0
+
+#define test_data_in            aes_ctr_null_enc_data_in
+#define test_data_out           aes_ctr_null_enc_data_out
+
+#define test_pdcp_hdr           aes_ctr_null_enc_pdcp_hdr
+#define test_bearer             aes_ctr_null_enc_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_AES
+#define test_integrity_algorithm SEC_ALG_NULL
+#define test_hfn                aes_ctr_null_enc_hfn
+#define test_hfn_threshold      aes_ctr_null_enc_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+
+#define test_crypto_key         aes_ctr_null_dec_key
+#define test_crypto_key_len     sizeof(aes_ctr_null_dec_key)
+
+#define test_auth_key           NULL
+#define test_auth_key_len       0
+
+#define test_data_in            aes_ctr_null_dec_data_in
+#define test_data_out           aes_ctr_null_dec_data_out
+
+#define test_pdcp_hdr           aes_ctr_null_dec_pdcp_hdr
+#define test_bearer             aes_ctr_null_dec_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_AES
+#define test_integrity_algorithm SEC_ALG_NULL
+#define test_hfn                aes_ctr_null_dec_hfn
+#define test_hfn_threshold      aes_ctr_null_dec_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
+
+#define test_crypto_key         NULL
+#define test_crypto_key_len     0
+
+#define test_auth_key           null_aes_cmac_enc_key
+#define test_auth_key_len       sizeof(null_aes_cmac_enc_key)
+
+#define test_data_in            null_aes_cmac_enc_data_in
+#define test_data_out           null_aes_cmac_enc_data_out
+
+#define test_pdcp_hdr           null_aes_cmac_enc_pdcp_hdr
+#define test_bearer             null_aes_cmac_enc_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_NULL
+#define test_integrity_algorithm SEC_ALG_AES
+#define test_hfn                null_aes_cmac_enc_hfn
+#define test_hfn_threshold      null_aes_cmac_enc_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
+
+#define test_crypto_key         NULL
+#define test_crypto_key_len     0
+
+#define test_auth_key           null_aes_cmac_dec_key
+#define test_auth_key_len       sizeof(null_aes_cmac_dec_key)
+
+#define test_data_in            null_aes_cmac_dec_data_in
+#define test_data_out           null_aes_cmac_dec_data_out
+
+#define test_pdcp_hdr           null_aes_cmac_dec_pdcp_hdr
+#define test_bearer             null_aes_cmac_dec_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_DECAPSULATION
+#define test_cipher_algorithm   SEC_ALG_NULL
+#define test_integrity_algorithm SEC_ALG_AES
+#define test_hfn                null_aes_cmac_dec_hfn
+#define test_hfn_threshold      null_aes_cmac_dec_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
 #else
 #error "Unsuported test scenario!"
 #endif
