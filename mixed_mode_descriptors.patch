diff --git a/sec-driver/src/sec_driver.c b/sec-driver/src/sec_driver.c
index e6687be..ad053dc 100755
--- a/sec-driver/src/sec_driver.c
+++ b/sec-driver/src/sec_driver.c
@@ -1262,7 +1262,7 @@ sec_return_code_t sec_init(const sec_config_t *sec_config_data,
     {
         SEC_INFO("Allocated %u KB for SEC driver, remaining free %lu KB",
                 ((dma_addr_t)g_dma_mem_free - (dma_addr_t)g_dma_mem_start)/1024,
-                (DMA_MEM_SEC_DRIVER - ((dma_addr_t)(dma_addr_t)g_dma_mem_free - (dma_addr_t)g_dma_mem_start))/1024);
+                (SEC_DMA_MEMORY_SIZE - ((dma_addr_t)(dma_addr_t)g_dma_mem_free - (dma_addr_t)g_dma_mem_start))/1024);
     }
     else
     {
diff --git a/sec-driver/src/sec_hw_specific.h b/sec-driver/src/sec_hw_specific.h
index 6960556..9cabbe6 100755
--- a/sec-driver/src/sec_hw_specific.h
+++ b/sec-driver/src/sec_hw_specific.h
@@ -517,6 +517,10 @@ but do not reset FIFO with jobs. See SEC 3.1 reference manual for more details.
 #define CMD_PROTO_DECAP                         0x06
 #define CMD_PROTO_ENCAP                         0x07
 
+#define CMD_ALGORITHM_ICV                       0x02
+
+#define CMD_ALGORITHM_ENCRYPT                   0x01
+
 #define PDCP_SD_KEY_LEN     0x4
 
 
@@ -793,8 +797,8 @@ but do not reset FIFO with jobs. See SEC 3.1 reference manual for more details.
             __i++)                                                          \
         {                                                                   \
             SEC_DEBUG("0x%08x: 0x%08x",                                     \
-                    (uint32_t)(((uint32_t*)(descriptor)) + __i),            \
-                    *(((uint32_t*)(descriptor)) + __i));                    \
+                     (uint32_t)(((uint32_t*)(descriptor)) + __i),           \
+                     *(((uint32_t*)(descriptor)) + __i));                   \
         }                                                                   \
 }
 
@@ -1102,11 +1106,13 @@ typedef struct sec_crypto_pdb_s
 struct sec_pdcp_sd_t{
     struct descriptor_header_s  deschdr;
     sec_crypto_pdb_t            pdb;
+
     struct key_command_s        key2_cmd;
     uint32_t                    key2[PDCP_SD_KEY_LEN];
     struct key_command_s        key1_cmd;
     uint32_t                    key1[PDCP_SD_KEY_LEN];
     struct protocol_operation_command_s protocol;
+
 } PACKED;
 
 /** Structure encompassing a job descriptor which processes
diff --git a/sec-driver/src/sec_pdcp.c b/sec-driver/src/sec_pdcp.c
index 50cfc53..5e6b202 100755
--- a/sec-driver/src/sec_pdcp.c
+++ b/sec-driver/src/sec_pdcp.c
@@ -1449,18 +1449,161 @@ static int create_c_plane_mixed_desc(sec_context_t *crypto_pdb)
     return SEC_SUCCESS;
 }
 
-static int create_c_plane_auth_only_desc(sec_context_t *crypto_pdb)
+static int create_c_plane_auth_only_desc(sec_context_t *ctx)
 {
-    SEC_INFO(" Called create_auth_only_desc");
-    ASSERT(0);
+    int i = 5;
+
+    switch( ctx->pdcp_crypto_info->integrity_algorithm )
+    {
+        case SEC_ALG_SNOW:
+            SEC_INFO(" SNOW f9 auth-only not supported.\n");
+            ASSERT(0);
+            break;
+        case SEC_ALG_AES:
+            SEC_INFO(" Creating NULL/AES-CMAC descriptor.");
+
+            ctx->sh_desc->deschdr.command.word  = 0xB8850100;
+            *((uint32_t*)ctx->sh_desc + i++) = 0x02800010;     // key1, imm, len 0x10
+            SEC_PDCP_SD_COPY_KEY( ((uint32_t*)(ctx->sh_desc) + i),
+                                   ctx->pdcp_crypto_info->integrity_key,
+                                   ctx->pdcp_crypto_info->integrity_key_len );
+            i+=ctx->pdcp_crypto_info->integrity_key_len/sizeof(uint32_t);
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x1e080001;     // seq load, class 3, length = 1, dest = m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa1001001;     // wait for calm
+            *((uint32_t*)ctx->sh_desc + i++) = 0xac804108;     // shift right 24 bits, put result in math1
+            *((uint32_t*)ctx->sh_desc + i++) = 0x00000018;     // 24
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79360808;     // move from desc buf to math2, wc=1,offset = 8, len 8
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa8412208;     // or Math2 w/Math1, put result in Math2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x78680008;     // move math2 to class1 input fifo(IV=64bits)
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x78480001;     // move math0 to class1 input fifo
+
+            if( ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION )
+            {
+                // outbound
+                *((uint32_t*)ctx->sh_desc + i++) = 0xa828f104;     // M1 = SIL-0x00
+            }
+            else
+            {
+                *((uint32_t*)ctx->sh_desc + i++) = 0xa8284104;  // M1 = SIL-0x04 (ICV size)
+                *((uint32_t*)ctx->sh_desc + i++) = 0x00000004;  // 4
+            }
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa821fa04;     // VSIL = M1-0x00
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa821fb04;     // VSOL = M1-0x00
+
+            if( ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION )
+            {
+                *((uint32_t*)ctx->sh_desc + i++) = 0x2f170000;  // seq fifo load, class1, class2, LC1, LC2, FC1 vlf
+            }
+            else
+            {
+                *((uint32_t*)ctx->sh_desc + i++) = 0x2f170000;  // seq fifo load, class1, class2, vlf
+                *((uint32_t*)ctx->sh_desc + i++) = 0x2e3f0004;  // seq fifo load, class1, class2, len = 4
+            }
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x8210060C | \
+                    ( (ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION) ? \
+                       0 : CMD_ALGORITHM_ICV );         // operation: optype = 2 (class 1), alg = 0x10 (aes), aai = 0x60 (cmac), as = 11 (int/fin), icv = 0, enc = 0 (ignored)
+            *((uint32_t*)ctx->sh_desc + i++) = 0x70920001;     // move from C2 align block to Output fifo, len = M1 = VSIL
+            *((uint32_t*)ctx->sh_desc + i++) = 0x5e080001;     // seq store, class 3, length = 1, src=m0 ( header )
+            *((uint32_t*)ctx->sh_desc + i++) = 0x69300000;     // seq fifo store, vlf
+
+            if( ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION )
+            {
+                *((uint32_t*)ctx->sh_desc + i++) = 0x5a200004;     // seqstr: ctx1 len=4 offs=0
+            }
+
+            // update descriptor length
+            ctx->sh_desc->deschdr.command.sd.desclen = i;
+
+            break;
+        default:
+            SEC_INFO(" Unknown integrity algorithm requested: %d", ctx->pdcp_crypto_info->integrity_algorithm);
+            ASSERT(0);
+            break;
+    }
+    SEC_PDCP_DUMP_DESC(ctx->sh_desc);
 
     return SEC_SUCCESS;
 }
 
-static int create_c_plane_cipher_only_desc(sec_context_t *crypto_pdb)
+static int create_c_plane_cipher_only_desc(sec_context_t *ctx)
 {
-    SEC_INFO(" Called create_cipher_only_desc");
-    ASSERT(0);
+    int i = 5;
+
+    switch( ctx->pdcp_crypto_info->cipher_algorithm )
+    {
+        case SEC_ALG_SNOW:
+            SEC_INFO(" Creating SNOW f8/NULL descriptor.");
+
+            ctx->sh_desc->deschdr.command.word = 0xb8850100;  // shared header, start idx = 5
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x02800010;  // key1, imm, len 0x10
+            SEC_PDCP_SD_COPY_KEY( ((uint32_t*)(ctx->sh_desc) + i),
+                                  ctx->pdcp_crypto_info->cipher_key,
+                                  ctx->pdcp_crypto_info->cipher_key_len );
+            i+=ctx->pdcp_crypto_info->cipher_key_len/sizeof(uint32_t);
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x1e080001;      // seq load, class 3, length = 1, dest = m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa1001001;      // wait for calm
+            *((uint32_t*)ctx->sh_desc + i++) = 0xac804108;      // shift right 24 bits, put result in math1
+            *((uint32_t*)ctx->sh_desc + i++) = 0x00000018;      // 24
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79360808;      // move from desc buf to math2, wc=1,offset = 8, len 8
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa8412208;      // or Math2 w/Math1, put result in Math2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x5e080001;      // seq store, class 3, length = 1, src=m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79600008;      // load, class1 ctx, math2, wc = 1, len 8, offset 0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa828fa04;      // VSIL=SIL-0x00
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa828fb04;      // VSOL=SOL-0x00
+            *((uint32_t*)ctx->sh_desc + i++) = 0x2b170000;      // seq fifo load, class1, vlf, LC1,LC2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x69300000;      // SEQ FIFO STORE, vlf
+            *((uint32_t*)ctx->sh_desc + i++) = 0x82600c0c| \
+                    ( (ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION) ? \
+                    CMD_ALGORITHM_ENCRYPT : 0 );      // operation, optype = 2 (class 1), alg = 0x60 (snow), aai = 0xC0 (f8), as = 11 (int/fin), icv = 0, enc = 0
+
+            // update descriptor length
+            ctx->sh_desc->deschdr.command.sd.desclen = i;
+
+            break;
+
+        case SEC_ALG_AES:
+            SEC_INFO(" Creating AES-CMAC/NULL descriptor.");
+
+            ctx->sh_desc->deschdr.command.word = 0xb8850100;  // shared header, start idx = 5
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x02800010;  // key1, imm, len 0x10
+            SEC_PDCP_SD_COPY_KEY( ((uint32_t*)(ctx->sh_desc) + i),
+                                  ctx->pdcp_crypto_info->cipher_key,
+                                  ctx->pdcp_crypto_info->cipher_key_len );
+            i+=ctx->pdcp_crypto_info->cipher_key_len/sizeof(uint32_t);
+
+            *((uint32_t*)ctx->sh_desc + i++) = 0x1e080001;  // seq load, class 3, length = 1, dest = m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa1001001;  // wait for calm
+            *((uint32_t*)ctx->sh_desc + i++) = 0xac804108;  // shift right 24 bits, put result in math1
+            *((uint32_t*)ctx->sh_desc + i++) = 0x00000018;  // 24
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79360808;  // move from desc buf to math2, wc=1,offset = 8, len 8
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa8412208;  // or Math2 w/Math1, put result in Math2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x5e080001;  // seq store, class 3, length = 1, src=m0
+            *((uint32_t*)ctx->sh_desc + i++) = 0x79601010;  // load, class1 ctx, math2, wc = 1, len 16, offset 16
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa828fa04;  // VSIL=SIL-0x00
+            *((uint32_t*)ctx->sh_desc + i++) = 0xa828fb04;  // VSOL=SIL-0x00
+            *((uint32_t*)ctx->sh_desc + i++) = 0x2b170000;  // seq fifo load, class1, vlf, LC1,LC2
+            *((uint32_t*)ctx->sh_desc + i++) = 0x69300000;  // SEQ FIFO STORE, vlf
+            *((uint32_t*)ctx->sh_desc + i++) = 0x8210000c | \
+                    ( (ctx->pdcp_crypto_info->protocol_direction == PDCP_ENCAPSULATION) ? \
+                       CMD_ALGORITHM_ENCRYPT : 0 );  // operation: optype = 2 (class 1), alg = 0x10 (aes), aai = 0x00 (ctr), as = 11 (int/fin), icv = 0, enc = 1
+
+            // update descriptor length
+            ctx->sh_desc->deschdr.command.sd.desclen = i;
+            break;
+        default:
+            SEC_INFO(" Unknown integrity algorithm requested: %d", ctx->pdcp_crypto_info->cipher_algorithm);
+            ASSERT(0);
+            break;
+    }
+
+    SEC_PDCP_DUMP_DESC(ctx->sh_desc);
 
     return SEC_SUCCESS;
 }
@@ -1590,9 +1733,9 @@ int sec_pdcp_context_update_descriptor(sec_context_t *ctx,
  */
 static create_desc_fp c_plane_create_desc[NUM_CIPHER_ALGS][NUM_INT_ALGS] = {
         /*              NULL                                SNOW                                    AES */
-        /* NULL */{create_null_desc,                create_c_plane_cipher_only_desc,    create_c_plane_cipher_only_desc },
-        /* SNOW */{create_c_plane_auth_only_desc,   create_c_plane_hw_acc_desc,         create_c_plane_mixed_desc       },
-        /* AES  */{create_c_plane_auth_only_desc,   create_c_plane_mixed_desc,          create_c_plane_hw_acc_desc      },
+        /* NULL */{create_null_desc,                  create_c_plane_auth_only_desc,      create_c_plane_auth_only_desc     },
+        /* SNOW */{create_c_plane_cipher_only_desc,   create_c_plane_hw_acc_desc,         create_c_plane_mixed_desc         },
+        /* AES  */{create_c_plane_cipher_only_desc,   create_c_plane_mixed_desc,          create_c_plane_hw_acc_desc        },
 };
 
 /** Static array for selection of the function to be used for creating the shared descriptor on a SEC context,
diff --git a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c
index 5ec55a1..3d6a310 100755
--- a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c
+++ b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.c
@@ -614,7 +614,7 @@ static int pdcp_ready_packet_handler (const sec_packet_t *in_packet,
     int test_failed = 0;
     // Check if packet is valid
     test_failed = !is_packet_valid(pdcp_context, in_packet, out_packet, status);
-
+test_printf("out packet lenght: %d\n",out_packet->length);
     if(test_failed)
     {
         test_printf("\nthread #%d:consumer: out packet INCORRECT!."
diff --git a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h
index 185b3a6..9cfdeb6 100755
--- a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h
+++ b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver.h
@@ -75,7 +75,7 @@
 
 // Test control plane PDCP with NULL-crypto(EEA0)
 // and NULL-authentication(EIA0) algorithms set
-#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_ALGO
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_ALGO
 
 // Test PDCP control plane encapsulation with SNOW F8 ciphering
 // and SNOW F9 authentication
@@ -87,7 +87,7 @@
 
 // Test PDCP control plane encapsulation with AES CTR ciphering
 // and AES CMAC authentication
-//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_AES_CTR_AES_CMAC_ENC
+#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_AES_CTR_AES_CMAC_ENC
 // Test PDCP control plane decapsulation with AES CTR ciphering
 // and AES CMAC authentication
 //#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_AES_CTR_AES_CMAC_DEC
@@ -107,12 +107,29 @@
 // and AES CMAC authentication
 //#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_SNOW_F8_AES_CMAC_DEC
 
+// Test PDCP control plane encapsulation with SNOW F8 ciphering
+// and NULL authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
 
 // Test PDCP control plane decapsulation with SNOW F8 ciphering
 // and NULL authentication
 //#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 
+// Test PDCP control plane encapsulation with AES-CTR ciphering
+// and NULL authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+
+// Test PDCP control plane decapsulation with AES-CTR ciphering
+// and NULL authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+
+// Test PDCP control plane encapsulation with NULL ciphering
+// and AES-CMAC authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
 
+// Test PDCP control plane decapsulation with NULL ciphering
+// and AES-CMAC authentication
+//#define PDCP_TEST_SCENARIO  PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
 
 
 //////////////////////////////////////////////////////////////////////////////
@@ -141,10 +158,10 @@
 //////////////////////////////////////////////////////////////////////////////
 
 // Disable test application logging
-#define test_printf(format, ...)
+//#define test_printf(format, ...)
 
 // Enable test application logging
-//#define test_printf(format, ...) printf("%s(): " format "\n", __FUNCTION__,  ##__VA_ARGS__)
+#define test_printf(format, ...) printf("%s(): " format "\n", __FUNCTION__,  ##__VA_ARGS__)
 
 /******************************************************************************/
 // END OF CONFIGURATION SECTION
@@ -181,7 +198,18 @@
 #define PDCP_TEST_CTRL_PLANE_AES_CTR_SNOW_F9_DEC    15
 #define PDCP_TEST_CTRL_PLANE_SNOW_F8_AES_CMAC_ENC   16
 #define PDCP_TEST_CTRL_PLANE_SNOW_F8_AES_CMAC_DEC   17
-#define PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC       18
+
+#define PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC       18
+#define PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC       19
+
+#define PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC       20
+#define PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC       21
+
+#define PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC      22
+#define PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC      23
+
+
+
 /*==============================================================================
                          GLOBAL VARIABLE DECLARATIONS
 ==============================================================================*/
diff --git a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h
index ae7f76b..13a9896 100755
--- a/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h
+++ b/sec-driver/tests/system-tests/test-scenario-poll-irq-napi/test_sec_driver_test_vectors.h
@@ -626,12 +626,12 @@ static uint8_t aes_ctr_cmac_dec_pdcp_hdr[] = {0x8B};
 
 // PDCP payload + MAC-I both encrypted
 static uint8_t aes_ctr_cmac_dec_data_in[] = {0xa1,0x05,0xfb,0xfe,0xa4,0x8d,0x74,0x3d,
-                                              0x29,0x53,0x27,0x33,0xd9,0xba,0x91,
-                                              // The MAC-I from packet
-                                              0x89,0x46,0x96,0xd6};
+                                             0x29,0x53,0x27,0x33,0xd9,0xba,0x91,
+                                             // The MAC-I from packet
+                                             0x89,0x46,0x96,0xd6};
 // PDCP payload not encrypted
 static uint8_t aes_ctr_cmac_dec_data_out[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
-                                         0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+                                              0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
 // Radio bearer id
 static uint8_t aes_ctr_cmac_dec_bearer = 0x3;
 
@@ -811,12 +811,80 @@ static uint32_t snow_f8_aes_cmac_dec_hfn = 0xFA556;
 static uint32_t snow_f8_aes_cmac_dec_hfn_threshold = 0xFF00000;
 
 //////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC"
+
+// Extracted from ETSI TS 135 203  V10.0.0  (2011-04)
+// Section 4, Test Set 3
+
+#define PDCP_HEADER_LENGTH 1
+
+static uint8_t snow_f8_null_enc_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
++                                    0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
+// PDCP header
+static uint8_t snow_f8_null_enc_pdcp_hdr[] = {0x26};
+
+// PDCP payload not encrypted
+static uint8_t snow_f8_null_enc_data_in[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                        0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+
+// PDCP payload encrypted
+static uint8_t snow_f8_null_enc_data_out[] = {0xBA,0x0F,0x31,0x30,0x03,0x34,0xC5,0x6B, // PDCP payload encrypted
+                                         0x52,0xA7,0x49,0x7C,0xBA,0xC0,0x46};
+
+// Radio bearer id
+static uint8_t snow_f8_null_enc_bearer = 0x3;
+
+// Start HFN
+static uint32_t snow_f8_null_enc_hfn = 0x7D2AB59;
+
+// HFN threshold
+static uint32_t snow_f8_null_enc_hfn_threshold = 0x7D2AB5a;
+
+//////////////////////////////////////////////////////////////////////////////
 // PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 //////////////////////////////////////////////////////////////////////////////
 #elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 
 #define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC"
 
+// Extracted from ETSI TS 135 203  V10.0.0  (2011-04)
+// Section 4, Test Set 3
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+
+static uint8_t snow_f8_null_dec_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
+                                    0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
+// PDCP header
+static uint8_t snow_f8_null_dec_pdcp_hdr[] = {0x26};
+
+// PDCP payload not encrypted
+static uint8_t snow_f8_null_dec_data_out[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                         0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+
+// PDCP payload encrypted
+static uint8_t snow_f8_null_dec_data_in[] = { 0xBA,0x0F,0x31,0x30,0x03,0x34,0xC5,0x6B, // PDCP payload encrypted
+                                         0x52,0xA7,0x49,0x7C,0xBA,0xC0,0x46};
+// Radio bearer id
+static uint8_t snow_f8_null_dec_bearer = 0x3;
+
+// Start HFN
+static uint32_t snow_f8_null_dec_hfn = 0x7D2AB59;
+
+// HFN threshold
+static uint32_t snow_f8_null_dec_hfn_threshold = 0xFA557;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC"
 // WE HAVE NO PDCP CONTROL-PLANE TEST VECTORS AVAILABLE!
 // Output data was obtained by running encapsulation test.
 // Then the reverse, decapsulation test was done to obtain back the original data.
@@ -825,33 +893,152 @@ static uint32_t snow_f8_aes_cmac_dec_hfn_threshold = 0xFF00000;
 // Length of PDCP header
 #define PDCP_HEADER_LENGTH 1
 
-// Crypto key
-static uint8_t snow_f8_null_dec_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
+
+static uint8_t aes_ctr_null_enc_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
                                          0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
-// Authentication key
-static uint8_t snow_f8_null_dec_auth_key[] = {0xC7,0x36,0xC6,0xAA,0xB2,0x2B,0xFF,0xF9,
-                                              0x1E,0x26,0x98,0xD2,0xE2,0x2A,0xD5,0x7E};
+
 // PDCP header
-static uint8_t snow_f8_null_dec_pdcp_hdr[] = {0x8B};
+static uint8_t aes_ctr_null_enc_pdcp_hdr[] = {0x8B};
 
-// PDCP payload + MAC-I both encrypted
-static uint8_t snow_f8_null_dec_data_in[] =  {0x20,0xd9,0x97,0x63,0x60,0x68,0x2d,0x55,0x0e,0x8d,
-                                              0x50,0x0a,0xc7,0xfc,0x5e};
+// PDCP payload not encrypted
+static uint8_t aes_ctr_null_enc_data_in[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                             0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8, /* payload */
+                                             0x1b, 0xd1, 0x65, 0x33 /* MAC-I */};
+
+// PDCP payload encrypted
+static uint8_t aes_ctr_null_enc_data_out[] = {0xa1,0x05,0xfb,0xfe,0xa4,0x8d,0x74,0x3d,
+                                              0x29,0x53,0x27,0x33,0xd9,0xba,0x91,
+                                              // The MAC-I from packet
+                                              0x89,0x46,0x96,0xd6};
+// Radio bearer id
+static uint8_t aes_ctr_null_enc_bearer = 0x03;
+// Start HFN
+
+static uint32_t aes_ctr_null_enc_hfn = 0xFA556;
+
+// HFN threshold
+static uint32_t aes_ctr_null_enc_hfn_threshold = 0xFF00000;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC"
+// WE HAVE NO PDCP CONTROL-PLANE TEST VECTORS AVAILABLE!
+// Output data was obtained by running encapsulation test.
+// Then the reverse, decapsulation test was done to obtain back the original data.
+// This is the method used for validating to some extent the PDCP control-plane algorithms.
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+
+static uint8_t aes_ctr_null_dec_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
+                                         0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
+
+// PDCP header
+static uint8_t aes_ctr_null_dec_pdcp_hdr[] = {0x8B};
 
 // PDCP payload not encrypted
-static uint8_t snow_f8_null_dec_data_out[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
-                                                  0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+static uint8_t aes_ctr_null_dec_data_out[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                              0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8,
+                                              0x1b, 0xd1, 0x65, 0x33 /* MAC-I */};
+
+
+// PDCP payload encrypted
+static uint8_t aes_ctr_null_dec_data_in[] = {0xa1,0x05,0xfb,0xfe,0xa4,0x8d,0x74,0x3d,
+                                             0x29,0x53,0x27,0x33,0xd9,0xba,0x91,
+                                             // The MAC-I from packet
+                                             0x89,0x46,0x96,0xd6};
 // Radio bearer id
-static uint8_t snow_f8_null_dec_bearer = 0x3;
+static uint8_t aes_ctr_null_dec_bearer = 0x03;
+
+// Start HFN
+static uint32_t aes_ctr_null_dec_hfn = 0xFA556;
+
+// HFN threshold
+static uint32_t aes_ctr_null_dec_hfn_threshold = 0xFF00000;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NUL_AES_CMAC_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC"
+// WE HAVE NO PDCP CONTROL-PLANE TEST VECTORS AVAILABLE!
+// Output data was obtained by running encapsulation test.
+// Then the reverse, decapsulation test was done to obtain back the original data.
+// This is the method used for validating to some extent the PDCP control-plane algorithms.
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+// PDCP header
+static uint8_t null_aes_cmac_enc_pdcp_hdr[] = {0x8B};
+
+static uint8_t null_aes_cmac_enc_auth_key[] = {0xC7,0x36,0xC6,0xAA,0xB2,0x2B,0xFF,0xF9,
+                                               0x1E,0x26,0x98,0xD2,0xE2,0x2A,0xD5,0x7E};
+
+// PDCP payload not encrypted
+static uint8_t null_aes_cmac_enc_data_out[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                               0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8,
+                                               // The MAC-I from packet
+                                               0x1b, 0xd1, 0x65, 0x33 };
+
+// PDCP payload encrypted
+static uint8_t null_aes_cmac_enc_data_in[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                              0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8};
+
+// Radio bearer id
+static uint8_t null_aes_cmac_enc_bearer = 0x3;
+
+// Start HFN
+static uint32_t null_aes_cmac_enc_hfn = 0xFA556;
+
+// HFN threshold
+static uint32_t null_aes_cmac_enc_hfn_threshold = 0xFF00000;
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NUL_AES_CMAC_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
+
+#define PDCP_TEST_SCENARIO_NAME "PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC"
+// WE HAVE NO PDCP CONTROL-PLANE TEST VECTORS AVAILABLE!
+// Output data was obtained by running encapsulation test.
+// Then the reverse, decapsulation test was done to obtain back the original data.
+// This is the method used for validating to some extent the PDCP control-plane algorithms.
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+// PDCP header
+static uint8_t null_aes_cmac_dec_pdcp_hdr[] = {0x8B};
+
+static uint8_t null_aes_cmac_dec_auth_key[] = {0xC7,0x36,0xC6,0xAA,0xB2,0x2B,0xFF,0xF9,
+                                               0x1E,0x26,0x98,0xD2,0xE2,0x2A,0xD5,0x7E};
+
+// PDCP payload not encrypted
+static uint8_t null_aes_cmac_dec_data_in[] = { 0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                               0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8,
+                                               // The MAC-I from packet
+                                               0x1b, 0xd1, 0x65, 0x33 };
+
+// PDCP payload encrypted
+static uint8_t null_aes_cmac_dec_data_out[] = {0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                               0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8 /* payload */};
+// Radio bearer id
+static uint8_t null_aes_cmac_dec_bearer = 0x3;
 
 // Start HFN
-static uint32_t snow_f8_null_dec_hfn = 0xFA556;
+static uint32_t null_aes_cmac_dec_hfn = 0xFA556;
 
 // HFN threshold
-static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
+static uint32_t null_aes_cmac_dec_hfn_threshold = 0xFF00000;
 
 #else
-#error "Unsuported test scenario!"
+#error "Unsupported test scenario!"
 #endif
 
 
@@ -1360,6 +1547,32 @@ static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
 //#endif
 
 //////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_ENC
+
+#define test_crypto_key         snow_f8_null_enc_key
+#define test_crypto_key_len     sizeof(snow_f8_null_enc_key)
+
+#define test_auth_key           NULL
+#define test_auth_key_len       0
+
+#define test_data_in            snow_f8_null_enc_data_in
+#define test_data_out           snow_f8_null_enc_data_out
+
+#define test_pdcp_hdr           snow_f8_null_enc_pdcp_hdr
+#define test_bearer             snow_f8_null_enc_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_SNOW
+#define test_integrity_algorithm SEC_ALG_NULL
+#define test_hfn                snow_f8_null_enc_hfn
+#define test_hfn_threshold      snow_f8_null_enc_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
 // PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
 //////////////////////////////////////////////////////////////////////////////
 #elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_SNOW_F8_NULL_DEC
@@ -1367,8 +1580,8 @@ static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
 #define test_crypto_key         snow_f8_null_dec_key
 #define test_crypto_key_len     sizeof(snow_f8_null_dec_key)
 
-#define test_auth_key           snow_f8_null_dec_auth_key
-#define test_auth_key_len       sizeof(snow_f8_null_dec_auth_key)
+#define test_auth_key           NULL
+#define test_auth_key_len       0
 
 #define test_data_in            snow_f8_null_dec_data_in
 #define test_data_out           snow_f8_null_dec_data_out
@@ -1390,6 +1603,111 @@ static uint32_t snow_f8_null_dec_hfn_threshold = 0xFF00000;
 //#ifdef VALIDATE_CONFORMITY
 //#undef VALIDATE_CONFORMITY
 //#endif
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_ENC
+
+#define test_crypto_key         aes_ctr_null_enc_key
+#define test_crypto_key_len     sizeof(aes_ctr_null_enc_key)
+
+#define test_auth_key           NULL
+#define test_auth_key_len       0
+
+#define test_data_in            aes_ctr_null_enc_data_in
+#define test_data_out           aes_ctr_null_enc_data_out
+
+#define test_pdcp_hdr           aes_ctr_null_enc_pdcp_hdr
+#define test_bearer             aes_ctr_null_enc_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_AES
+#define test_integrity_algorithm SEC_ALG_NULL
+#define test_hfn                aes_ctr_null_enc_hfn
+#define test_hfn_threshold      aes_ctr_null_enc_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_AES_CTR_NULL_DEC
+
+#define test_crypto_key         aes_ctr_null_dec_key
+#define test_crypto_key_len     sizeof(aes_ctr_null_dec_key)
+
+#define test_auth_key           NULL
+#define test_auth_key_len       0
+
+#define test_data_in            aes_ctr_null_dec_data_in
+#define test_data_out           aes_ctr_null_dec_data_out
+
+#define test_pdcp_hdr           aes_ctr_null_dec_pdcp_hdr
+#define test_bearer             aes_ctr_null_dec_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_AES
+#define test_integrity_algorithm SEC_ALG_NULL
+#define test_hfn                aes_ctr_null_dec_hfn
+#define test_hfn_threshold      aes_ctr_null_dec_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_ENC
+
+#define test_crypto_key         NULL
+#define test_crypto_key_len     0
+
+#define test_auth_key           null_aes_cmac_enc_auth_key
+#define test_auth_key_len       sizeof(null_aes_cmac_enc_auth_key)
+
+#define test_data_in            null_aes_cmac_enc_data_in
+#define test_data_out           null_aes_cmac_enc_data_out
+
+#define test_pdcp_hdr           null_aes_cmac_enc_pdcp_hdr
+#define test_bearer             null_aes_cmac_enc_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_ENCAPSULATION
+#define test_cipher_algorithm   SEC_ALG_NULL
+#define test_integrity_algorithm SEC_ALG_AES
+#define test_hfn                null_aes_cmac_enc_hfn
+#define test_hfn_threshold      null_aes_cmac_enc_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
+//////////////////////////////////////////////////////////////////////////////
+// PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
+//////////////////////////////////////////////////////////////////////////////
+#elif PDCP_TEST_SCENARIO == PDCP_TEST_CTRL_PLANE_NULL_AES_CMAC_DEC
+
+#define test_crypto_key         NULL
+#define test_crypto_key_len     0
+
+#define test_auth_key           null_aes_cmac_dec_auth_key
+#define test_auth_key_len       sizeof(null_aes_cmac_dec_auth_key)
+
+#define test_data_in            null_aes_cmac_dec_data_in
+#define test_data_out           null_aes_cmac_dec_data_out
+
+#define test_pdcp_hdr           null_aes_cmac_dec_pdcp_hdr
+#define test_bearer             null_aes_cmac_dec_bearer
+#define test_sn_size            SEC_PDCP_SN_SIZE_5
+#define test_user_plane         PDCP_CONTROL_PLANE
+#define test_packet_direction   PDCP_DOWNLINK
+#define test_protocol_direction PDCP_DECAPSULATION
+#define test_cipher_algorithm   SEC_ALG_NULL
+#define test_integrity_algorithm SEC_ALG_AES
+#define test_hfn                null_aes_cmac_dec_hfn
+#define test_hfn_threshold      null_aes_cmac_dec_hfn_threshold
+#define test_packet_offset      PACKET_OFFSET
+
 #else
 #error "Unsuported test scenario!"
 #endif
diff --git a/sec-driver/tests/unit-tests/api_tests/api_tests.c b/sec-driver/tests/unit-tests/api_tests/api_tests.c
index 5c0677d..6759f5e 100755
--- a/sec-driver/tests/unit-tests/api_tests/api_tests.c
+++ b/sec-driver/tests/unit-tests/api_tests/api_tests.c
@@ -2571,5 +2571,4 @@ int main(int argc, char *argv[])
 
 #ifdef __cplusplus
 }
-p
 #endif
diff --git a/sec-driver/tests/unit-tests/mixed-descs-tests/Makefile.am b/sec-driver/tests/unit-tests/mixed-descs-tests/Makefile.am
new file mode 100644
index 0000000..55c9da0
--- /dev/null
+++ b/sec-driver/tests/unit-tests/mixed-descs-tests/Makefile.am
@@ -0,0 +1,10 @@
+bin_PROGRAMS = mixed_descs_tests
+
+AM_CFLAGS := -I$(TOP_LEVEL)/sec-driver/src
+AM_CFLAGS += -I$(TOP_LEVEL)/sec-driver/include
+AM_CFLAGS += -I$(TOP_LEVEL)/utils/of/include
+AM_CFLAGS += -I$(TOP_LEVEL)/utils/dma_mem/include
+AM_CFLAGS += -I$(TOP_LEVEL)/utils/test-frameworks/cgreen
+
+mixed_descs_tests_SOURCES := mixed_descs_tests.c
+mixed_descs_tests_LDADD := cgreen sec-driver of dma_mem
diff --git a/sec-driver/tests/unit-tests/mixed-descs-tests/mixed_descs_tests.c b/sec-driver/tests/unit-tests/mixed-descs-tests/mixed_descs_tests.c
new file mode 100755
index 0000000..6c94f42
--- /dev/null
+++ b/sec-driver/tests/unit-tests/mixed-descs-tests/mixed_descs_tests.c
@@ -0,0 +1,1343 @@
+/* Copyright (c) 2011 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Create one context for each supported algorithm, uplink and downlink
+ * Check that the results from the output of one algorithm match the results from the other one
+ * i.e. AES_CTR(AES_CMAC(msg)) == AES_CMAC_CTR(msg)
+ * Scenario 1 (both ul and dl):
+ *             msg->auth(msg)->enc(auth(msg)) \
+ *                                            |=> compare the two, fail if they don't match
+ *                              auth_enc(msg) /
+ * Scenario 2 (both ul and dl):
+ *            msg->dec(msg)->auth_check(dec(auth(msg)))  \
+ *                                                        |=> compare the two, fail if they don't match
+ *                                    auth_check_dec(msg) /
+ */
+
+#ifdef _cplusplus
+extern "C" {
+#endif
+
+/*=================================================================================================
+                                        INCLUDE FILES
+==================================================================================================*/
+#include "fsl_sec.h"
+#include "cgreen.h"
+// for dma_mem library
+#include "compat.h"
+
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <unistd.h>
+
+/*==================================================================================================
+                                     LOCAL DEFINES
+==================================================================================================*/
+// Number of SEC JRs used by this test application
+// @note: Currently this test application supports only 2 JRs (not less, not more).
+//        The DTS must have configured SEC device with at least 2 user space owned job rings!
+#define JOB_RING_NUMBER 2
+
+// max number of packets used in this test
+#define TEST_PACKETS_NUMBER 50
+
+// Number of bytes representing the offset into a packet,
+// where the PDCP header will start.
+#define TEST_PACKET_OFFSET  4
+
+// Size in bytes for the buffer occupied by a packet.
+// Includes offset.
+#define TEST_PACKET_LENGTH  50
+
+// Alignment in bytes for input/output packets allocated from DMA-memory zone
+#define BUFFER_ALIGNEMENT 32
+
+// Size in bytes for the buffer used by a packet.
+// A packet can use less but not more than this number of bytes.
+#define BUFFER_SIZE 200
+
+// Max length in bytes for a confidentiality /integrity key.
+#define MAX_KEY_LENGTH    32
+
+/** Size in bytes of a cacheline. */
+#define CACHE_LINE_SIZE  32
+
+// Number of SEC contexts in each pool. Define taken from SEC user-space driver.
+#define MAX_SEC_CONTEXTS_PER_POOL   (SEC_MAX_PDCP_CONTEXTS / (JOB_RING_NUMBER))
+
+// Length of PDCP header
+#define PDCP_HEADER_LENGTH 1
+
+#define DUMP_PACKET(in_pkt)                             \
+    {                                                   \
+        int __i;                                        \
+        printf("Packet @ address : 0x%08x\n",(in_pkt)->address);   \
+        for( __i = 0; __i < (in_pkt)->offset + (in_pkt)->length; __i++)  \
+        {                                               \
+           printf("0x%02x\n",                           \
+           *((uint8_t*)((in_pkt)->address) + __i ));    \
+        }                                               \
+    }
+/*==================================================================================================
+                          LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
+==================================================================================================*/
+/** Enum for packet states */
+typedef enum buffer_state_s
+{
+    STATE_UNUSED = 0,
+    STATE_USED
+}buffer_state_t;
+
+/** Structure to define packet info */
+typedef struct buffer_s
+{
+    uint8_t buffer[BUFFER_SIZE];
+    uint32_t offset;
+    sec_packet_t pdcp_packet;
+    buffer_state_t state;
+}buffer_t;
+
+/*==================================================================================================
+                                     GLOBAL VARIABLES
+==================================================================================================*/
+// configuration data for SEC driver
+static sec_config_t sec_config_data;
+
+// job ring handles provided by SEC driver
+static const sec_job_ring_descriptor_t *job_ring_descriptors = NULL;
+
+// array of packets
+buffer_t *test_packets = NULL;
+
+// User App specific data for every packet
+uint8_t ua_data[TEST_PACKETS_NUMBER];
+
+// cipher key, required for every PDCP context
+static uint8_t *cipher_key = NULL;
+
+// integrity key, required for every PDCP context
+static uint8_t *integrity_key = NULL;
+
+// Crypto key
+static uint8_t test_crypto_key[] = {0x5A,0xCB,0x1D,0x64,0x4C,0x0D,0x51,0x20,
+                                    0x4E,0xA5,0xF1,0x45,0x10,0x10,0xD8,0x52};
+
+// Authentication key
+static uint8_t test_auth_key[] = {0xC7,0x36,0xC6,0xAA,0xB2,0x2B,0xFF,0xF9,
+                                  0x1E,0x26,0x98,0xD2,0xE2,0x2A,0xD5,0x7E};
+
+// Input test vector, used in encap packets
+static uint8_t test_data_in_encap[] = { 0xAD,0x9C,0x44,0x1F,0x89,0x0B,0x38,0xC4,
+                                  0x57,0xA4,0x9D,0x42,0x14,0x07,0xE8 };
+
+// Output test vector, used in decap packets for downlink
+static uint8_t test_data_in_decap_dl[] = {0xa1,0x05,0xfb,0xfe,0xa4,0x8d,0x74,0x3d,
+                                  0x29,0x53,0x27,0x33,0xd9,0xba,0x91,
+                                  // The MAC-I from packet
+                                  0x89,0x46,0x96,0xd6};
+
+// Output test vector, used in decap packets for downlink
+static uint8_t test_data_in_decap_ul[] = {0x1f,0x75,0x2f,0x84,0xec,0x10,0x97,0xb8,
+                                0x3a,0x2e,0x89,0xe8,0x6f,0x81,0x21,
+                                // The MAC-I from packet
+                                0x6d,0x69,0x42,0x95};
+
+static uint8_t  test_pdcp_hdr = 0x8B;
+
+static uint8_t test_bearer = 0x3;
+
+static uint32_t test_hfn = 0xFA556;
+
+static uint32_t test_hfn_threshold = 0xFF00000;
+
+/*==================================================================================================
+                                 LOCAL FUNCTION PROTOTYPES
+==================================================================================================*/
+// Callback function registered for every PDCP context to handle procesed packets.
+static int handle_packet_from_sec(const sec_packet_t *in_packet,
+                                  const sec_packet_t *out_packet,
+                                  ua_context_handle_t ua_ctx_handle,
+                                  uint32_t status,
+                                  uint32_t error_info);
+
+// Get packet from the global array with test packets.
+static int get_pkt(sec_packet_t **pkt,uint8_t *data, int pkt_len);
+
+// Return packet in the global array with test packets.
+static int put_pkt(sec_packet_t **pkt);
+
+/*==================================================================================================
+                                     LOCAL FUNCTIONS
+==================================================================================================*/
+static int handle_packet_from_sec(const sec_packet_t *in_packet,
+                                  const sec_packet_t *out_packet,
+                                  ua_context_handle_t ua_ctx_handle,
+                                  uint32_t status,
+                                  uint32_t error_info)
+{
+    int ret = SEC_SUCCESS;
+
+    return ret;
+}
+
+static int get_pkt(sec_packet_t **pkt,uint8_t *data, int pkt_len)
+{
+    int packet_idx;
+    
+    *pkt = NULL;
+    
+    if( pkt_len == 0)
+        return -1;
+
+    for( packet_idx = 0; packet_idx < TEST_PACKETS_NUMBER; packet_idx++ )
+    {
+        if( test_packets[packet_idx].state == STATE_UNUSED )
+        {
+            /* found it */
+            test_packets[packet_idx].state = STATE_USED;
+            
+            *pkt = &test_packets[packet_idx].pdcp_packet;
+            
+            (*pkt)->address = &(test_packets[packet_idx].buffer[0]);
+            (*pkt)->offset = TEST_PACKET_OFFSET;
+            (*pkt)->total_length = 0;
+            (*pkt)->num_fragments = 0;
+            (*pkt)->length = pkt_len + PDCP_HEADER_LENGTH;
+            
+            if( data != NULL )
+            {
+                // copy PDCP header
+                memcpy((*pkt)->address + (*pkt)->offset, &test_pdcp_hdr, sizeof(test_pdcp_hdr));
+                // copy input data
+                memcpy((*pkt)->address + (*pkt)->offset + PDCP_HEADER_LENGTH,
+                        data,
+                        pkt_len);
+            }
+            else
+            {
+                /* set everything to 0 */
+                memset((*pkt)->address + (*pkt)->offset, 0x00, sizeof(test_pdcp_hdr));
+                memset((*pkt)->address + (*pkt)->offset + PDCP_HEADER_LENGTH, 0x00, pkt_len);
+            }
+            break;
+        }
+    }
+    
+    return 0;
+}
+
+static int put_pkt(sec_packet_t **pkt)
+{
+    int pkt_idx;
+
+    for( pkt_idx = 0; pkt_idx < TEST_PACKETS_NUMBER; pkt_idx++)
+    {
+        if( *pkt == &test_packets[pkt_idx].pdcp_packet )
+        {
+            /* found it */
+            if( test_packets[pkt_idx].state == STATE_UNUSED)
+                return -1;
+
+            /* set everything to 0 */
+            memset((*pkt)->address + (*pkt)->offset, 0x00, sizeof(test_pdcp_hdr));
+            memset((*pkt)->address + (*pkt)->offset + PDCP_HEADER_LENGTH, 0x00, TEST_PACKET_LENGTH);
+
+            *pkt = NULL;
+
+            test_packets[pkt_idx].state = STATE_UNUSED;
+
+            break;
+        }
+    }
+    
+    return 0;
+}
+
+
+static void test_setup(void)
+{
+    int ret = 0;
+
+    // map the physical memory
+    ret = dma_mem_setup(SEC_DMA_MEMORY_SIZE, CACHE_LINE_SIZE);
+    assert_equal_with_message(ret, 0, "ERROR on dma_mem_setup: ret = %d", ret);
+
+    // Fill SEC driver configuration data
+    sec_config_data.memory_area = (void*)__dma_virt;
+    sec_config_data.work_mode = SEC_STARTUP_POLLING_MODE;
+
+    cipher_key = dma_mem_memalign(BUFFER_ALIGNEMENT, MAX_KEY_LENGTH);
+    assert_not_equal_with_message(cipher_key, NULL, "ERROR allocating cipher_key with dma_mem_memalign");
+    memset(cipher_key, 0, MAX_KEY_LENGTH);
+    memcpy(cipher_key, test_crypto_key, sizeof(test_crypto_key));
+
+    integrity_key = dma_mem_memalign(BUFFER_ALIGNEMENT, MAX_KEY_LENGTH);
+    assert_not_equal_with_message(integrity_key, NULL, "ERROR allocating integrity_key with dma_mem_memalign");
+    memset(integrity_key, 0, MAX_KEY_LENGTH);
+    memcpy(integrity_key, test_auth_key, sizeof(test_auth_key));
+
+    test_packets = dma_mem_memalign(BUFFER_ALIGNEMENT,
+            sizeof(buffer_t) * TEST_PACKETS_NUMBER);
+    assert_not_equal_with_message(test_packets, NULL,
+            "ERROR allocating test_packets with dma_mem_memalign");
+    memset(test_packets, 0, sizeof(buffer_t) * TEST_PACKETS_NUMBER);
+
+    memset(ua_data, 0x3, TEST_PACKETS_NUMBER);
+}
+
+static void test_teardown()
+{
+    int ret = 0;
+
+    // unmap the physical memory
+    ret = dma_mem_release();
+    assert_equal_with_message(ret, 0, "ERROR on dma_mem_release: ret = %d", ret);
+
+    dma_mem_free(cipher_key, MAX_KEY_LENGTH);
+    dma_mem_free(integrity_key, MAX_KEY_LENGTH);
+    dma_mem_free(test_packets, sizeof(buffer_t) * TEST_PACKETS_NUMBER);
+}
+
+static void test_c_plane_mixed_downlink_encap(void)
+{
+    int ret = 0;
+    int limit = SEC_JOB_RING_SIZE  - 1;
+    int i = 0;
+    uint32_t packets_out = 0;
+    uint32_t packets_handled = 0;
+    sec_job_ring_handle_t jr_handle_0;
+    sec_job_ring_handle_t jr_handle_1;
+    sec_context_handle_t ctx_handle_0 = NULL;
+    sec_context_handle_t ctx_handle_1 = NULL;
+    sec_context_handle_t ctx_handle_2 = NULL;
+    sec_packet_t *in_pkt = NULL, *auth_ciphered_pkt_dbl_pass = NULL,*auth_ciphered_pkt=NULL, *auth_only_pkt = NULL;
+    int memcmp_res = 0;
+    // configuration data for a PDCP context
+    sec_pdcp_context_info_t ctx_info[3] = {
+        /* auth-only */
+        {
+            .cipher_algorithm       = SEC_ALG_NULL,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* cipher-only */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_NULL,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* auth+cipher */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        }
+    };
+
+
+    printf("Running test %s\n", __FUNCTION__);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // Init sec driver. No invalid param.
+    ret = sec_init(&sec_config_data, JOB_RING_NUMBER, &job_ring_descriptors);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_init: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+
+    jr_handle_0 = job_ring_descriptors[0].job_ring_handle;
+    jr_handle_1 = job_ring_descriptors[1].job_ring_handle;
+
+    ctx_info[0].packet_direction = 
+    ctx_info[1].packet_direction = 
+    ctx_info[2].packet_direction = PDCP_DOWNLINK;
+    
+    ctx_info[0].protocol_direction = 
+    ctx_info[1].protocol_direction = 
+    ctx_info[2].protocol_direction = PDCP_ENCAPSULATION;
+
+    ////////////////////////////////////    
+    ////////////////////////////////////
+
+    // Create one context and affine it to first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[0], &ctx_handle_0);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    // Create another context and affine it to the first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[1], &ctx_handle_1);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+            
+    // Create another context and affine it to the second job ring.
+    ret = sec_create_pdcp_context(jr_handle_1, &ctx_info[2], &ctx_handle_2);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+    
+    // How many packets to send and receive to/from SEC
+    packets_handled = 1;
+    
+    // Get one packet to be used as input for both procedures
+    ret = get_pkt(&in_pkt,test_data_in_encap,sizeof(test_data_in_encap));
+    assert_equal_with_message(ret, 0,
+            "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+            0, ret);
+            
+    // Get one packet to be used for auth output
+    ret = get_pkt(&auth_only_pkt,NULL,sizeof(test_data_in_encap) + 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+            "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+            0, ret);
+
+    // Submit one packet on the first context for authentication
+    ret = sec_process_packet(ctx_handle_0, in_pkt, auth_only_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+    
+    // Get one packet to be used for auth+enc output in dbl pass
+    ret = get_pkt(&auth_ciphered_pkt_dbl_pass,NULL,sizeof(test_data_in_encap) + 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+    
+    // Submit one packet on the second context for ciphering
+    ret = sec_process_packet(ctx_handle_1, auth_only_pkt, auth_ciphered_pkt_dbl_pass, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+        
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    // Get one packet to be used for auth+enc output in one pass
+    ret = get_pkt(&auth_ciphered_pkt,NULL,sizeof(test_data_in_encap) + 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+    
+    // Submit one packet on the third context for ciphering and authentication in one pass
+    ret = sec_process_packet(ctx_handle_2, in_pkt, auth_ciphered_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_1, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+                              
+    // assert that the pkts obtained through the two methods are bit-exact
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset,
+                        PDCP_HEADER_LENGTH);
+    if ( memcmp_res != 0 )
+    {
+        printf("Error comparing headers:\n");
+    }
+    printf("Double pass header  |  Single Pass header\n");
+    printf("0x%02x                |                0x%02x\n",
+            *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset),
+            *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset) );
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: header is different!");
+                        
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->length - PDCP_HEADER_LENGTH);
+    if (memcmp_res != 0)
+    {
+        printf("Error comparing contents:\n");
+    }
+
+    printf("Double pass content |  Single Pass content\n");
+    for( i = 0; i < auth_ciphered_pkt->length - PDCP_HEADER_LENGTH; i++)
+    {
+        printf("0x%02x                |                0x%02x\n",
+                *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH + i),
+                *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH + i) );
+    }
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: content is different!");
+
+    put_pkt(&in_pkt);
+    put_pkt(&auth_only_pkt);
+    put_pkt(&auth_ciphered_pkt_dbl_pass);
+    put_pkt(&auth_ciphered_pkt);
+
+    // release sec driver
+    ret = sec_release();
+    assert_equal_with_message(ret, SEC_SUCCESS, "ERROR on sec_release: ret = %d", ret);
+    
+}
+
+static void test_c_plane_mixed_downlink_decap(void)
+{
+    int ret = 0;
+    int limit = SEC_JOB_RING_SIZE  - 1;
+    int i = 0;
+    uint32_t packets_out = 0;
+    uint32_t packets_handled = 0;
+    sec_job_ring_handle_t jr_handle_0;
+    sec_job_ring_handle_t jr_handle_1;
+    sec_context_handle_t ctx_handle_0 = NULL;
+    sec_context_handle_t ctx_handle_1 = NULL;
+    sec_context_handle_t ctx_handle_2 = NULL;
+    sec_packet_t *in_pkt = NULL, *auth_ciphered_pkt_dbl_pass = NULL,*auth_ciphered_pkt=NULL, *auth_only_pkt = NULL;
+    int memcmp_res = 0;
+    // configuration data for a PDCP context
+    sec_pdcp_context_info_t ctx_info[3] = {
+        /* cipher-only */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_NULL,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* auth-only */
+        {
+            .cipher_algorithm       = SEC_ALG_NULL,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* auth+cipher */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        }
+    };
+
+
+    printf("Running test %s\n", __FUNCTION__);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // Init sec driver. No invalid param.
+    ret = sec_init(&sec_config_data, JOB_RING_NUMBER, &job_ring_descriptors);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_init: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+
+    jr_handle_0 = job_ring_descriptors[0].job_ring_handle;
+    jr_handle_1 = job_ring_descriptors[1].job_ring_handle;
+
+    ctx_info[0].packet_direction =
+    ctx_info[1].packet_direction =
+    ctx_info[2].packet_direction = PDCP_DOWNLINK;
+
+    ctx_info[0].protocol_direction =
+    ctx_info[1].protocol_direction =
+    ctx_info[2].protocol_direction = PDCP_DECAPSULATION;
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // Create one context and affine it to first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[0], &ctx_handle_0);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    // Create another context and affine it to the first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[1], &ctx_handle_1);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    // Create another context and affine it to the second job ring.
+    ret = sec_create_pdcp_context(jr_handle_1, &ctx_info[2], &ctx_handle_2);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // How many packets to send and receive to/from SEC
+    packets_handled = 1;
+
+    ret = get_pkt(&in_pkt,test_data_in_decap_dl,sizeof(test_data_in_decap_dl));
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+
+    // Get one packet to be used for auth output
+    ret = get_pkt(&auth_only_pkt,NULL,sizeof(test_data_in_decap_dl));
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+
+    // Submit one packet on the first context for decryption
+    ret = sec_process_packet(ctx_handle_0, in_pkt, auth_only_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    ret = get_pkt(&auth_ciphered_pkt_dbl_pass,NULL,sizeof(test_data_in_decap_dl) - 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                    "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                    0, ret);
+
+    // Submit one packet on the second context for ciphering
+    ret = sec_process_packet(ctx_handle_1, auth_only_pkt, auth_ciphered_pkt_dbl_pass, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    ret = get_pkt(&auth_ciphered_pkt,NULL,sizeof(test_data_in_decap_dl) - 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                    "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                    0, ret);
+
+    // Submit one packet on the third context for ciphering and authentication in one pass
+    ret = sec_process_packet(ctx_handle_2, in_pkt, auth_ciphered_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_1, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    // assert that the pkts obtained through the two methods are bit-exact
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset,
+                        PDCP_HEADER_LENGTH);
+    if ( memcmp_res != 0 )
+    {
+        printf("Error comparing headers:\n");
+    }
+    printf("Double pass header  |  Single Pass header\n");
+    printf("0x%02x                |                0x%02x\n",
+            *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset),
+            *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset) );
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: header is different!");
+
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->length - PDCP_HEADER_LENGTH);
+    if (memcmp_res != 0)
+    {
+        printf("Error comparing contents:\n");
+    }
+
+    printf("Double pass content |  Single Pass content\n");
+    for( i = 0; i < auth_ciphered_pkt->length - PDCP_HEADER_LENGTH; i++)
+    {
+        printf("0x%02x                |                0x%02x\n",
+                *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH + i),
+                *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH + i) );
+    }
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: content is different!");
+
+    put_pkt(&in_pkt);
+    put_pkt(&auth_only_pkt);
+    put_pkt(&auth_ciphered_pkt_dbl_pass);
+    put_pkt(&auth_ciphered_pkt);
+
+    // release sec driver
+    ret = sec_release();
+    assert_equal_with_message(ret, SEC_SUCCESS, "ERROR on sec_release: ret = %d", ret);
+
+}
+
+static void test_c_plane_mixed_uplink_encap(void)
+{
+    int ret = 0;
+    int limit = SEC_JOB_RING_SIZE  - 1;
+    int i = 0;
+    uint32_t packets_out = 0;
+    uint32_t packets_handled = 0;
+    sec_job_ring_handle_t jr_handle_0;
+    sec_job_ring_handle_t jr_handle_1;
+    sec_context_handle_t ctx_handle_0 = NULL;
+    sec_context_handle_t ctx_handle_1 = NULL;
+    sec_context_handle_t ctx_handle_2 = NULL;
+    sec_packet_t *in_pkt = NULL,*auth_ciphered_pkt_dbl_pass = NULL,*auth_ciphered_pkt=NULL, *auth_only_pkt = NULL;
+    int memcmp_res = 0;
+    // configuration data for a PDCP context
+    sec_pdcp_context_info_t ctx_info[3] = {
+        /* auth-only */
+        {
+            .cipher_algorithm       = SEC_ALG_NULL,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* cipher-only */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_NULL,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* auth+cipher */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        }
+    };
+
+
+    printf("Running test %s\n", __FUNCTION__);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // Init sec driver. No invalid param.
+    ret = sec_init(&sec_config_data, JOB_RING_NUMBER, &job_ring_descriptors);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_init: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+
+    jr_handle_0 = job_ring_descriptors[0].job_ring_handle;
+    jr_handle_1 = job_ring_descriptors[1].job_ring_handle;
+
+    ctx_info[0].packet_direction =
+    ctx_info[1].packet_direction =
+    ctx_info[2].packet_direction = PDCP_UPLINK;
+
+    ctx_info[0].protocol_direction =
+    ctx_info[1].protocol_direction =
+    ctx_info[2].protocol_direction = PDCP_ENCAPSULATION;
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // Create one context and affine it to first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[0], &ctx_handle_0);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    // Create another context and affine it to the first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[1], &ctx_handle_1);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    // Create another context and affine it to the second job ring.
+    ret = sec_create_pdcp_context(jr_handle_1, &ctx_info[2], &ctx_handle_2);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // How many packets to send and receive to/from SEC
+    packets_handled = 1;
+
+    ret = get_pkt(&in_pkt,test_data_in_encap,sizeof(test_data_in_encap));
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+
+    // Get one packet to be used for auth output
+    ret = get_pkt(&auth_only_pkt,NULL,sizeof(test_data_in_encap) + 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+
+    // Submit one packet on the first context for authentication
+    ret = sec_process_packet(ctx_handle_0, in_pkt, auth_only_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    ret = get_pkt(&auth_ciphered_pkt_dbl_pass,NULL,sizeof(test_data_in_encap) + 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                    "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                    0, ret);
+
+    // Submit one packet on the second context for ciphering
+    ret = sec_process_packet(ctx_handle_1, auth_only_pkt, auth_ciphered_pkt_dbl_pass, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    ret = get_pkt(&auth_ciphered_pkt,NULL,sizeof(test_data_in_encap) + 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                    "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                    0, ret);
+
+    // Submit one packet on the third context for ciphering and authentication in one pass
+    ret = sec_process_packet(ctx_handle_2, in_pkt, auth_ciphered_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_1, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    // assert that the pkts obtained through the two methods are bit-exact
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset,
+                        PDCP_HEADER_LENGTH);
+    if ( memcmp_res != 0 )
+    {
+        printf("Error comparing headers:\n");
+    }
+    printf("Double pass header  |  Single Pass header\n");
+    printf("0x%02x                |                0x%02x\n",
+            *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset),
+            *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset) );
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: header is different!");
+
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->length - PDCP_HEADER_LENGTH);
+    if (memcmp_res != 0)
+    {
+        printf("Error comparing contents:\n");
+    }
+
+    printf("Double pass content |  Single Pass content\n");
+    for( i = 0; i < auth_ciphered_pkt->length - PDCP_HEADER_LENGTH; i++)
+    {
+        printf("0x%02x                |                0x%02x\n",
+                *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH + i),
+                *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH + i) );
+    }
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: content is different!");
+
+    put_pkt(&in_pkt);
+    put_pkt(&auth_only_pkt);
+    put_pkt(&auth_ciphered_pkt_dbl_pass);
+    put_pkt(&auth_ciphered_pkt);
+
+    // release sec driver
+    ret = sec_release();
+    assert_equal_with_message(ret, SEC_SUCCESS, "ERROR on sec_release: ret = %d", ret);
+
+}
+static void test_c_plane_mixed_uplink_decap(void)
+{
+    int ret = 0;
+    int limit = SEC_JOB_RING_SIZE  - 1;
+    int i = 0;
+    uint32_t packets_out = 0;
+    uint32_t packets_handled = 0;
+    sec_job_ring_handle_t jr_handle_0;
+    sec_job_ring_handle_t jr_handle_1;
+    sec_context_handle_t ctx_handle_0 = NULL;
+    sec_context_handle_t ctx_handle_1 = NULL;
+    sec_context_handle_t ctx_handle_2 = NULL;
+    sec_packet_t *in_pkt = NULL, *auth_ciphered_pkt_dbl_pass = NULL,*auth_ciphered_pkt=NULL, *auth_only_pkt = NULL;
+    int memcmp_res = 0;
+    // configuration data for a PDCP context
+    sec_pdcp_context_info_t ctx_info[3] = {
+        /* cipher-only */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_NULL,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* auth-only */
+        {
+            .cipher_algorithm       = SEC_ALG_NULL,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        },
+        /* auth+cipher */
+        {
+            .cipher_algorithm       = SEC_ALG_AES,
+            .cipher_key             = cipher_key,
+            .cipher_key_len         = sizeof(test_crypto_key),
+            .integrity_algorithm    = SEC_ALG_AES,
+            .integrity_key          = integrity_key,
+            .integrity_key_len      = sizeof(test_auth_key),
+            .notify_packet          = &handle_packet_from_sec,
+            .sn_size                = SEC_PDCP_SN_SIZE_5,
+            .bearer                 = test_bearer,
+            .user_plane             = PDCP_CONTROL_PLANE,
+            //.packet_direction       = test_pkt_dir;
+            //.protocol_direction     = test_proto_dir;
+            .hfn                    = test_hfn,
+            .hfn_threshold          = test_hfn_threshold
+        }
+    };
+
+
+    printf("Running test %s\n", __FUNCTION__);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // Init sec driver. No invalid param.
+    ret = sec_init(&sec_config_data, JOB_RING_NUMBER, &job_ring_descriptors);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_init: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+
+    jr_handle_0 = job_ring_descriptors[0].job_ring_handle;
+    jr_handle_1 = job_ring_descriptors[1].job_ring_handle;
+
+    ctx_info[0].packet_direction =
+    ctx_info[1].packet_direction =
+    ctx_info[2].packet_direction = PDCP_UPLINK;
+
+    ctx_info[0].protocol_direction =
+    ctx_info[1].protocol_direction =
+    ctx_info[2].protocol_direction = PDCP_DECAPSULATION;
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // Create one context and affine it to first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[0], &ctx_handle_0);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    // Create another context and affine it to the first job ring.
+    ret = sec_create_pdcp_context(jr_handle_0, &ctx_info[1], &ctx_handle_1);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    // Create another context and affine it to the second job ring.
+    ret = sec_create_pdcp_context(jr_handle_1, &ctx_info[2], &ctx_handle_2);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+            "ERROR on sec_create_pdcp_context: expected ret[%d]. actual ret[%d]",
+            SEC_SUCCESS, ret);
+
+    ////////////////////////////////////
+    ////////////////////////////////////
+
+    // How many packets to send and receive to/from SEC
+    packets_handled = 1;
+
+    ret = get_pkt(&in_pkt,test_data_in_decap_ul,sizeof(test_data_in_decap_ul));
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+
+    // Get one packet to be used for auth output
+    ret = get_pkt(&auth_only_pkt,NULL,sizeof(test_data_in_decap_ul));
+    assert_equal_with_message(ret, 0,
+                "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                0, ret);
+
+    // Submit one packet on the first context for decryption
+    ret = sec_process_packet(ctx_handle_0, in_pkt, auth_only_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    ret = get_pkt(&auth_ciphered_pkt_dbl_pass,NULL,sizeof(test_data_in_decap_ul) - 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                    "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                    0, ret);
+
+    // Submit one packet on the second context for ciphering
+    ret = sec_process_packet(ctx_handle_1, auth_only_pkt, auth_ciphered_pkt_dbl_pass, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_0, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    ret = get_pkt(&auth_ciphered_pkt,NULL,sizeof(test_data_in_decap_ul) - 4 /* ICV size */);
+    assert_equal_with_message(ret, 0,
+                    "ERROR on get_pkt: expected ret[%d]. actual ret[%d]",
+                    0, ret);
+
+    // Submit one packet on the third context for ciphering and authentication in one pass
+    ret = sec_process_packet(ctx_handle_2, in_pkt, auth_ciphered_pkt, NULL);
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                    "ERROR on sec_process_packet: expected ret[%d]. actual ret[%d]",
+                    SEC_SUCCESS, ret);
+
+    usleep(1000);
+    ret = sec_poll_job_ring(jr_handle_1, limit, &packets_out);
+
+    assert_equal_with_message(ret, SEC_SUCCESS,
+                              "ERROR on sec_poll: expected ret[%d]. actual ret[%d]",
+                              SEC_SUCCESS, ret);
+    // <packets_handled> packets should be retrieved from SEC
+    assert_equal_with_message(packets_out, packets_handled,
+                              "ERROR on sec_poll: expected packets notified[%d]."
+                              "actual packets notified[%d]",
+                              packets_handled, packets_out);
+
+    // assert that the pkts obtained through the two methods are bit-exact
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset,
+                        PDCP_HEADER_LENGTH);
+    if ( memcmp_res != 0 )
+    {
+        printf("Error comparing headers:\n");
+    }
+    printf("Double pass header  |  Single Pass header\n");
+    printf("0x%02x                |                0x%02x\n",
+            *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset),
+            *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset) );
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: header is different!");
+
+    memcmp_res = memcmp(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH,
+                        auth_ciphered_pkt->length - PDCP_HEADER_LENGTH);
+    if (memcmp_res != 0)
+    {
+        printf("Error comparing contents:\n");
+    }
+
+    printf("Double pass content |  Single Pass content\n");
+    for( i = 0; i < auth_ciphered_pkt->length - PDCP_HEADER_LENGTH; i++)
+    {
+        printf("0x%02x                |                0x%02x\n",
+                *(uint8_t*)(auth_ciphered_pkt_dbl_pass->address + auth_ciphered_pkt_dbl_pass->offset + PDCP_HEADER_LENGTH + i),
+                *(uint8_t*)(auth_ciphered_pkt->address + auth_ciphered_pkt->offset + PDCP_HEADER_LENGTH + i) );
+    }
+
+    assert_equal_with_message(memcmp_res, 0,
+                              "ERROR on checking packet contents: content is different!");
+
+    put_pkt(&in_pkt);
+    put_pkt(&auth_only_pkt);
+    put_pkt(&auth_ciphered_pkt_dbl_pass);
+    put_pkt(&auth_ciphered_pkt);
+
+    // release sec driver
+    ret = sec_release();
+    assert_equal_with_message(ret, SEC_SUCCESS, "ERROR on sec_release: ret = %d", ret);
+
+}
+
+static TestSuite * mixed_descs_tests()
+{
+    /* create test suite */
+    TestSuite * suite = create_test_suite();
+
+    /* setup/teardown functions to be called before/after each unit test */
+    setup(suite, test_setup);
+    teardown(suite, test_teardown);
+
+    /* start adding unit tests */
+    add_test(suite, test_c_plane_mixed_downlink_encap);
+    add_test(suite, test_c_plane_mixed_uplink_encap);
+    add_test(suite, test_c_plane_mixed_downlink_decap);
+    add_test(suite, test_c_plane_mixed_uplink_decap);
+
+    return suite;
+}
+
+/*==================================================================================================
+                                     GLOBAL FUNCTIONS
+==================================================================================================*/
+
+int main(int argc, char *argv[])
+{
+    /* *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** */
+    /* Be aware that by using run_test_suite() instead of run_single_test(), CGreen will execute
+     * each test case in a separate UNIX process, so:
+     * (1) unit tests' thread safety might need to be ensured by defining critical regions
+     *     (beware, CGreen error messages are not explanatory and intuitive enough)
+     *
+     * Although it is more difficult to maintain synchronization manually,
+     * it is recommended to run_single_test() for each test case.
+     */
+
+    /* create test suite */
+    TestSuite * suite = mixed_descs_tests();
+    TestReporter * reporter = create_text_reporter();
+
+    /* Run tests */
+
+    run_single_test(suite, "test_c_plane_mixed_downlink_encap", reporter);
+    run_single_test(suite, "test_c_plane_mixed_uplink_encap", reporter);
+    run_single_test(suite, "test_c_plane_mixed_downlink_decap", reporter);
+    run_single_test(suite, "test_c_plane_mixed_uplink_decap", reporter);
+
+    destroy_test_suite(suite);
+    (*reporter->destroy)(reporter);
+
+    return 0;
+} /* main() */
+
+/*================================================================================================*/
+
+#ifdef __cplusplus
+}
+
+#endif
